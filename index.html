<!DOCTYPE html>
<html>
<head>
  <title>Live Health Monitor</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    .alert { color: red; font-weight: bold; }
  </style>
</head>
<body>
  <h2>Heart Rate: <span id="hr">--</span> BPM</h2>
  <div id="hrAlert" class="alert"></div>

  <h2>SpO2: <span id="spo2">--</span> %</h2>
  <div id="spo2Alert" class="alert"></div>

  <canvas id="ecgChart" width="800" height="300"></canvas>
  <br>
  <button onclick="connectSerial()">Connect ESP via USB</button>

  <script>
    let port;
    let readBuffer = ""; // For collecting partial serial data

    const HR_BUFFER_SIZE = 10;
    const SPO2_BUFFER_SIZE = 10;
    let hrBuffer = Array(HR_BUFFER_SIZE).fill(0);
    let spo2Buffer = Array(SPO2_BUFFER_SIZE).fill(0);
    let hrIndex = 0, spo2Index = 0;

    const MAX_POINTS = 100; // Keep only last 100 points for scrolling

    const ecgData = {
      labels: Array(MAX_POINTS).fill(''),
      datasets: [{
        label: 'ECG Signal',
        data: Array(MAX_POINTS).fill(150), // start at baseline
        borderColor: 'red',
        fill: false,
        tension: 0.3 // smoother curves
      }]
    };

    const ecgChart = new Chart(document.getElementById('ecgChart'), {
      type: 'line',
      data: ecgData,
      options: {
        animation: false,
        scales: {
          x: { display: false },
          y: { suggestedMin: 140, suggestedMax: 160 } // initial range
        }
      }
    });

    async function connectSerial() {
      try {
        port = await navigator.serial.requestPort();
        await port.open({ baudRate: 115200 });

        const decoder = new TextDecoderStream();
        port.readable.pipeTo(decoder.writable);
        const inputStream = decoder.readable.getReader();

        while (true) {
          const { value, done } = await inputStream.read();
          if (done) break;
          if (value) handleSerialData(value);
        }
      } catch (err) {
        alert("Failed to connect: " + err);
      }
    }

    function handleSerialData(chunk) {
      readBuffer += chunk;
      let lines = readBuffer.split("\n");
      readBuffer = lines.pop(); // keep incomplete line

      for (let line of lines) {
        processLine(line.trim());
      }
    }

    function movingAverage(buffer, newValue, index) {
      buffer[index] = newValue;
      return buffer.reduce((a,b) => a+b, 0) / buffer.length;
    }

    function processLine(line) {
      if (!line.includes(",")) return;
      const parts = line.split(",");
      if (parts.length < 3) return;

      const hr = parseFloat(parts[0]);
      const spo2 = parseFloat(parts[1]);
      const ecg = parseFloat(parts[2]);

      if (isNaN(hr) || isNaN(spo2) || isNaN(ecg)) return;

      // Smooth HR and SpO2
      const avgHR = movingAverage(hrBuffer, hr, hrIndex);
      const avgSpO2 = movingAverage(spo2Buffer, spo2, spo2Index);
      hrIndex = (hrIndex + 1) % HR_BUFFER_SIZE;
      spo2Index = (spo2Index + 1) % SPO2_BUFFER_SIZE;

      // Update UI
      document.getElementById('hr').innerText = avgHR.toFixed(1);
      document.getElementById('spo2').innerText = avgSpO2.toFixed(1);

      document.getElementById('hrAlert').innerText =
        (avgHR > 120) ? "⚠️ High heart rate!" :
        (avgHR < 50) ? "⚠️ Low heart rate!" : "";

      document.getElementById('spo2Alert').innerText =
        (avgSpO2 < 90) ? "⚠️ Low SpO2 level!" : "";

      // --- Update ECG chart with analog-like waveform ---
      const baseline = 150; // midpoint of sensor
      const scale = 5;      // amplify small variations
      const smoothECG = baseline + (ecg - baseline) * scale;

      ecgData.datasets[0].data.push(smoothECG);
      ecgData.datasets[0].data.shift(); // remove oldest point

      // Auto-scale y-axis
      const recentData = ecgData.datasets[0].data;
      const minECG = Math.min(...recentData);
      const maxECG = Math.max(...recentData);
      ecgChart.options.scales.y.min = minECG - 5;
      ecgChart.options.scales.y.max = maxECG + 5;

      ecgChart.update();
    }
  </script>
</body>
</html>
